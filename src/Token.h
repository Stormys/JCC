#ifndef TOKEN_H
#define TOKEN_H
#include <string>
class Token
{
public:
	static enum Kind { SUBASSIGN, ADDASSIGN, MULASSIGN, DIVASSIGN, MODASSIGN, LOGICAL_NOT, NOT_EQUAL, LESS_THAN, LESS_THAN_EQUAL, GREATER_THAN, GREATER_THAN_EQUAL,
		BINARY_LEFT_SHIFT, BINARY_RIGHT_SHIFT, BINARY_LEFT_SHIFT_ASSIGN, BINARY_RIGHT_SHIFT_ASSIGN,
		LOGICAL_AND, BINARY_AND, BINARY_AND_ASSIGN, LOGICAL_OR, BINARY_OR, BINARY_OR_ASSIGN,
		BINARY_XOR, BINARY_ONES_COMPLEMENT, BINARY_XOR_ASSIGN, COLON, REGISTER, DO,
		COMMA, PERIOD, LEFT_BRACKET, RIGHT_BRACKET, STRUCT_ELEMENT, EQUAL, AUTO, BREAK,GOTO, LONG, WHILE,TYPEDEF,
		DOUBLE,STRUCT,ELSE, ENUM, EXTERN, WARNING, INT,IF, VOLATILE, VOID, FLOAT, FOR, OPEN_PAREN, CLOSE_PAREN, OPEN_CURLY, CLOSE_CURLY, SEMICOLON, RETURN, ADD, SUBTRACT,
		DIVIDE, MULTIPLY, ASSIGN, MODULUS, INCREMENT, DECREMENT, CASE, CHAR, CONST, CONTINUE, DEFAULT, SHORT, SIGNED, SIZEOF, STATIC, SWITCH, UNION, UNSIGNED,
		IDENTIFIER, INTEGER, ERROR1, E0F, CHAR_CONSTANT, C_STRING
	} Type;
	static std::string Kind_TEXT[];
	Token(Kind temp, const std::string& lexeme);
	~Token();

	const std::string& get_lexeme();
	Kind get_kind();

private:
	std::string lexeme;
	Kind kind;
};
#endif
